# 数学基础 #
## 特征值与特征向量 ##
设A是n阶方阵，如果数λ与非零列向量x有公式：
```
Ax=λX
```
成立，那么λ为方阵A的特征值，x为λ的特征向量。
## 正定矩阵 半正定矩阵 ##
【定义1】给定一个大小为 n*n 的实对称矩阵A ，若对于任意长度为n的非零向量x，有xTAX>0恒成立，则矩阵A是一个正定矩阵。

【定义2】给定一个大小为 n*n 的实对称矩阵A ，若对于任意长度为n的非零向量x，有xTAX>=0恒成立，则矩阵A是一个正定矩阵。
半正定包含正定。
xTAX可以类比ax^2>=0
## 特征分解 ##
- **方阵**

A为方阵，那么A有如下分解：
```
A=Q∑Q-1或A=Q∑QT
```
Q为A的特征向量组成的正交矩阵，∑为特征值组成的对角阵。
- **m*n矩阵**

1. svd分解

   对于m*n的矩阵A，有如下分解：
```
A=U∑VT
```
U为m*m矩阵，V为n*n矩阵，∑为奇异值组成的对角阵。

求解U：
AAT为m*m阶矩阵，对该矩阵进行特征向量求解，由特征向量组成的方阵为U；

求解V：
ATA为n*n阶实对称矩阵，对该矩阵进行特征向量求解，由特征向量组成的方阵为V；

求解∑：

2. QR分解
   
对于任意矩阵A，可以将其分解成一个正交阵Q和一个上三角矩阵R的乘积；
```
A=QR
```
3. LU分解
对于任意矩阵，可以将其分解成一个下三角矩阵L和上三角矩阵U的乘积；
```
A=LU
```
4. cholesky分解

A为实对称正交矩阵，可以分解成一个下三角矩阵L与L的共轭转置矩阵；
```
A=LL*
```

 ## 矩阵逆求解 ##
- 矩阵的逆

  对于矩阵A，如果存在一个矩阵B，使得AB=BA=E，其中E为与A、B同维数的单位阵，就称为可逆矩阵
- 矩阵的伪逆

  奇异矩阵（行列式为0的方阵）和非方阵没有逆，但有伪逆矩阵。
  满足ALA=E，但不满足AAL=E的矩阵AL称为A的左逆矩阵，同理满足AAR=E，不满足ARA=E的矩阵AR称为矩阵A的右逆矩阵。
  
  m>=n,Am*n有左逆矩阵，AL=（ATA）-1AT
  n>=m,Am*n有右逆矩阵，AR=AT（ATA）-1
  m=n，Am*n的秩r<=m=n,对A进行奇异值分解A=U∑VT
  A的逆矩阵为A+=V∑+U
- 求逆的方法
  
1. svd分解
```
A=U∑VT,A-1=V∑+UT
```
2. QR分解
## 线性方程 ##
1. 齐次方程AX=0
   1. R(A) < n,有多非0解；
   2. R(A) = n,只有0解（满秩）；
   3. R(A) > n,无解，但可求最小二乘解。 （n为未知数个数，R(A)为系数矩阵的秩）
2. 非齐次方程AX=b
   1. R(A) < n,有多非0解；
   2. R(A) = n,唯一解（满秩）；
   3. R(A) > n,无解，但可求最小二乘解。 （n为未知数个数，R(A)为系数矩阵的秩）
## 最小二乘法求解 ##
- **线性** 

1. AX=0（齐次）

解为A的右奇异矩阵V的最后一列, 即 ATA 最小特征值对应的特征向量.

构建最小二乘问题
```
min||AX||, 约束：||X||=1
A=UDVT
||AX||=||U∑VTX||=||∑VTX||, U是正交矩阵，去掉不影响行列式大小
VTX为列矩阵，有：
||VTX||=||X||=1，VT为正交矩阵，去掉不影响行列式大小
∑对角元素为奇异值，当假设最后一个对角元素为最小奇异值，且：
VTX=[0 0 0...1]T
X=V[0 0 0 ...1]T=[v1 v2 v3 ... vn][0 0 0...1]T
最优解为:vn列向量
```

2. AX=b（非齐次）
   
   1. 直接法：
   ```
   X=A-1 * b, 直接求解A的伪逆A-1，使用QR，SVD
   ```
   2. 构建最小二乘：
   ```
   w=min||AX-b||
   最小二乘的解为：X=(ATA)-1ATb, X=QR
   RTQTQRX=RTQTb
   QRX=b
   RX=QTb
   X=R-1QTb
   ```
   3. 最小二乘法矩阵求导
- **非线性**   
   迭代法

   # Ubuntu18.03 slam 环境配置 #
   ## Eigen install ##
   ```
   apt-get install libeigen3-dev

   CMakeList.txt中添加
   include_directories("/usr/include/eigen3")
   ```

   ## pangolin ##
   ```
   git clone https://github.com/stevenlovegrove/Pangolin.git
   apt-get install libglew-dev
   apt-get install cmake
   apt-get install libpython2.7-dev
   apt-get install ffmpeg libavcodec-dev libavutil-dev libavformat-dev libswscale-dev libavdevice-dev
   apt-get install libdc1394-22-dev libraw1394-dev
   apt-get install libjpeg-dev libpng12-dev libtiff5-dev libopenexr-dev
   apt-get install libxkbcommon-dev
   apt-get install wayland-protocols
   ```
   ## Sophus install ##
   ```
   git clone https://github.com/strasdat/Sophus.git
   cd Sophus
   mkdir build
   cd build
   cmake ..
   make

   CMakeList.txt中添加
   # add sophus lib
   find_package(Sophus REQUIRED)
   include_directories(${Sophus_INCLUDE_DIRS})
   target_link_libraries( 可执行文件名 Sophus::Sophus )
   ```
   ## Opencv install ##
   ```
   apt-get update
   apt-get upgrade
   add-apt-repository "deb http://security.ubuntu.com/ubuntu xenial-security main" 
   apt update
   apt-get install build-essential libgtk2.0-dev libvtk7-dev libjpeg-dev libtiff5-dev libjasper-dev libopenexr-dev libtbb-dev
   cd opencv-4.5.3
   mkdir build
   cmake ..
   make -j8
   make install 
   ldconfig           # 而当用户安装了一个新的动态链接库时，需要手工运行这个命令

   CMakeList.txt中添加
   # add opencv 
   find_package(OpenCV REQUIRED)
   include_directories({$OpenCV_INCLUDE_DIRS})
   target_link_libraries( 可执行文件名 ${OpenCV_LIBS})
   ```
   ## Ceres install ##
   ```
   apt-get install liblapack-dev libsuitesparse-dev libcxsparse3 libgflags-dev libgoogle-glog-dev libgtest-dev
   cd ceres-solver
   mkdir build
   cmake ..
   make -j8
   make install
   ldconfig           # 而当用户安装了一个新的动态链接库时，需要手工运行这个命令

   CMakeList.txt中添加
   # add ceres
   find_package(Ceres REQUIRED)
   include_directories({$CERES_INCLUDE_DIRS})
   target_link_libraries( 可执行文件名 ${CERES_LIBRARIES})
   ```

   ## g20 install ##
   ```
   apt-get install qt5-qmake qt5-default libqglviewer-dev-qt5 libsuitesparse-dev libcxsparse3 libcholmod3
   cd g2o
   mkdir build
   cmake ..
   make -j8
   make install
   ldconfig           # 而当用户安装了一个新的动态链接库时，需要手工运行这个命令

   CMakeList.txt中添加
   # add g2o
   list( APPEND CMAKE_MODULE_PATH /home/cuihang/g2o/cmake_modules )
   set(G2O_ROOT /usr/local/include/g2o)
   find_package(G2O)
   include_directories({$G2O_INCLUDE_DIRS})
   target_link_libraries(可执行文件名 ${G2O_CORE_LIBRARY} ${G2O_STUFF_LIBRARY})

   ## gtsam install ##
   ```
   git clone https://bitbucket.org/gtborg/gtsam.git
   sudo apt-get install libboost-all-dev
   sudo apt-get install cmake
   sudo apt-get install libtbb-dev
   mkdir build
   cd build
   cmake ..
   make 
   sudo make install

   CMakeList.txt中添加
   # add gtsam
   INCLUDE_DIRECTORIES(${Boost_INCLUDE_DIR})
   INCLUDE_DIRECTORIES(${GTSAM_INCLUDE_DIR})
   find_package(Boost COMPONENTS thread filesystem date_time system REQUIRED)
   FIND_PACKAGE(GTSAM REQUIRED)
   ```
   ## CMakeList.txt 配置样例 ##
   ```
   cmake_minimum_required(VERSION 2.8)
   project(工程名)
   # add eigen
   include_directories("/usr/include/eigen3")

   # add opencv 
   find_package(OpenCV REQUIRED)
   include_directories({$OpenCV_INCLUDE_DIRS})


   # add sophus lib
   find_package(Sophus REQUIRED)
   include_directories(${Sophus_INCLUDE_DIRS})

   # add ceres
   find_package(Ceres REQUIRED)
   include_directories({$CERES_INCLUDE_DIRS})

   # add g2o
   # 修改为自己g2o的路径
   list( APPEND CMAKE_MODULE_PATH /home/g2o/cmake_modules )  
   set(G2O_ROOT /usr/local/include/g2o)
   find_package(G2O)
   include_directories({$G2O_INCLUDE_DIRS})

   add_executable(可执行文件名 ./src/main.cpp)

   target_link_libraries( 可执行文件名 Sophus::Sophus )
   target_link_libraries( 可执行文件名 ${OpenCV_LIBS})
   target_link_libraries( 可执行文件名 ${CERES_LIBRARIES})
   target_link_libraries( 可执行文件名 ${G2O_CORE_LIBRARY} ${G2O_STUFF_LIBRARY})
   ```

   ## SLAM系统 ##
   ### 双目（14讲） ###
1. 第一帧（初始化）：
   1. 左图特征点检测；
   2. 光流法右图对应特征点检测；
   3. 根据左右两图的位姿，三角化求匹配特征点的世界坐标，也就是地图点，并加入地图集合中（第一帧左图为世界坐标系原点，左右图位姿已知）；
2. 第二帧：
   1. 根据第一帧左图特征点，使用光流法求第二帧左图的特征点；
   2. BA优化求的第二帧左图的位姿（特征点世界坐标系在第一帧里已求得）；
   3. 重新检测第二帧左图特征点；
   4. 光流法计算第二帧右图特征点；
   5. 根据第二帧左右两图位姿，三角化求匹配特征点的世界坐标，加入到地图集合中；
3. 第三帧～最后一帧：
   1. 根据前一帧左图特征点，使用光流法求当前帧左图的特征点；
   2. BA优化求的当前帧左图的位姿（特征点世界坐标系在前一帧里已求得）；
   3. 重新检测当前帧左图特征点；
   4. 光流法计算当前帧右图特征点；
   5. 根据当前帧左右两图位姿，三角化求匹配特征点的世界坐标，加入到地图集合中，并设置关键帧（关键帧规则（两帧匹配特征点小于阈值则设为关键帧））；
   6. 并激活后端优化。
   关键帧问题：如果每帧之间匹配特征点过多，怎么办，都不设为关键帧吗？应该改进为当前帧与上一关键帧之间的的特征点比较或距离比较
   关键帧改进：保持全局关键帧的数量为定值，如果关键帧数量超出阈值，那么将原先的关键帧合并。
   ### 单目（svo改造） ###
4. 初始化（前两帧）
   1. 第一帧特征点检测；
   2. 光流法跟踪第二帧特征点；
   3. 对极约束获得两帧的姿态关系；
   4. 三角化获得路标点（特征点的世界坐标）；
   5. BA优化，包括姿态、路标点；
   6. 第二帧特征点重新检测（如果前面光流跟踪的特征点少于阈值）。
5. 跟踪（从第三帧开始）
   1. 光流法跟踪当前帧特征点；
   2. pnp获得前一帧与当前帧之间的位姿关系；
   3. BA优化位姿关系；
   4. 三角化得到路标点；
   5. 路标点BA优化（位姿与路标点分开优化，效率更高）；
   6. 当前帧特征点重新检测（如果千米光流跟踪特征点少于阈值）；
   7. 全剧BA优化，包括姿态、路标点（在固定帧数进行优化）。 
   ## 光流法 ##
   ### 前向 ###
   基于灰度不变假设，通俗说的意思是：对于前后两帧图形中的特征点(x, y)和(x+Δx, y+Δy)，理论上来说其灰度是相同的，I1(x,y) == I2(x+Δx,y+Δy)。现在已知上一帧灰度I1(x,y)和坐标(x, y)，求Δx, Δy？
   构建最小二乘：
   ```
   minΔxi,Δyi∑W||I1(xi,yi)−I2(xi+Δxi,yi+Δyi)||22
   ```
   迭代求解(一次迭代iter)：
   1. 构建error：
   ```
   e=I1(x,y)−I2(x+Δx,y+Δy)
   ```
   1. 求rror对每一个要求未知量的偏导，构建雅可比矩阵：
   ```
   ∂e/∂Δx=−(∂I2(x+Δx,y+Δy)/∂Δx)
   ∂e/∂Δy=−(∂I2(x+Δx,y+Δy)/∂Δy)
   J = [∂e/∂Δx, ∂e/∂Δy]
   ```
   1. 计算Hession矩阵和g:
   ```
   H=∑J * J.transpose()
   g=∑-error * J
   其中累加次数为一次迭代iter中完成的所有数据
   ```
   1. 构建线性方程H*ΔX=g:
   求解：ΔX_update = H.ldlt().solve(b)
   1. 更新Δx, Δy：
   Δx += ΔX_update[0]
   Δy += ΔX_update[1]
   
   那么最后求得第二帧特征点坐标为(x+Δx, y+Δy)。
   ### 后向 ###
   在你实现了上述算法之后，就会发现，在迭代开始时，Gauss-Newton 的计算依赖于 I2 在 (xi+Δxi,yi+Δyi) 处的梯度信息。然而，角点提取算法仅保证了 I1(xi,yi) 处是角点（可以认为角度点存在明显梯度），但对于 I2，我们并没有办法假设 I2 在 xi,yi 处亦有梯度，从而 Gauss−Newton 并不一定成立。反向的光流法（inverse）则做了一个巧妙的技巧，即用 I1(xi,yi) 处的梯度，替换掉原本要计算的 I2(xi+Δxi,yi+Δyi)的梯度。这样做的好处有：
   * I1(xi,yi)是角点，梯度总有意义；
   * I1(xi,yi)处的梯度不随迭代改变，所以只需计算一次，就可以在后续的迭代中一直使用，节省了大量计算时间。

   我们为 OpticalFlowSingleLevel 函数添加一个 bool inverse 参数，指定要使用正常的算法还是反向的算法。请你根据上述说明，完成反向的 LK 光流法：
   ```
   error=I2(x,y)−I1(x−dx,y−dy)
   ∂e/∂dx=∂I1(x−dx)/∂x
   ```
   ### 金字塔 ###
   对同一张图像进行不同分辨率的缩放，从金字塔最上层开始光流跟踪，下一层以上一层的结果为初始值继续跟踪，直到最后一层输出最后的结果。对于运动幅度比较大的两帧，有很好的跟踪效果。
   ## 非线性优化 ##
   ### g2o ###
6. 创建节点，节点为需要优化的参数，一般继承g2o::BaseVertex<维度，数据类型>；
   1. 重置函数setOrigImpl，目的是将待估计的参数初始化，列入
      1. 曲线的待优化系数a、b、c，那么可以初始化为:_estimate << 0, 0, 0;
      2. 两帧相机姿态待优化系数为矩阵，那么可以初始化：_estimate = SE3();
   2. 更新函数oplusImpl，每次更新的增量ΔX，不同参数更新取不同值（容易理解，不同参数类型更新不一样），例如：
      1. 曲线参数用加法更新：_estimate += Eigen::Vector3d(update);
      2. 位姿参数用矩阵相乘：_estimate = SE3::exp(update_eigen)*_estimate; 
7. 创建边，边为数据，边分为一元边、二元边与多元边：
   1. g2o::BaseUnaryEdge<维度，类型，顶点类型>(一元边)
   2. g2o::BaseBinaryEdge<维度，类型，顶点类型>（二元边）
   3. g2o::BaseMultiEdge<维度，类型，顶点类型>(多元边)
   边类的成员函数也有两部分：误差模型、计算雅可比矩阵。
   1. 误差模型computError():error(0,0) = measurement - 估计值；
   2. linearizeOplus():雅可比矩阵_jacobianOpluXi[0]= **;_jacobianOplusXi[1]= **;_jacobianOplusXi[n]= **;
8. 定义求解器：
   1. 线性求解器LinearSolver；
   2. 块求解器BlockSolver，用线性求解器初始化；
   3. 总求解器solver，并从GN，LM，DogLeg中选一个，再用上述块求解器BlockSolver初始化；
9.  创建稀疏优化器（图模型）SparseOptimizer optimizer,将总求解器solver添加；
10. 依次添加所有种类顶点：
    1. 由上面定义的顶点类创建顶点对象v;
    2. 将所有顶点加入v中，v->setEstimate(顶点);
    3. 设置顶点ID，v->setId(i);
    4. 将v添加进图模型中，optimizer.addVertex(v).
11. 依次添加所有边（数据），用边将所有顶点连接；
    1. 由上面定义的边类创建边对象edge；
    2. 设置边ID,edge->setId(i)
    3. 设置连接顶点edge->setVertex(i,v)
    4. 设置观测值edge->setMeasurement(y);
    5. 设置协方差矩阵之逆edge->setInformation,协方差矩阵之逆为信息矩阵。
    6. 设置鲁棒核函数auto rk = new g2o::RobustKernelHuber(),edge->setRobustKernel(rk).
### ceres ###
三种求导方式：
1. 自动求导；
2. 数值求导；
3. 解析求导；
   定义的类继承ceres::SizedCostFunction
   Evaluate()
   1. 计算残差residuals[0] = **;residuals[1]= **;
   2. 计算雅可比矩阵jacobian1[0]= **；
   ceres的更新默认是加法，如果是矩阵更新，需要重载ceres::LocalParameterization中的Plus函数。
## CMakeLists工程构建 ##
project_name
|__ cmake_modules
    cmake1.cmake ...
|__ bin                         // 可执行文件目录
   |__ main1 ...
|__ example
   |__ main1.cpp ...            // 可执行文件源码
   |__ CMakeLists.txt
|__ include
   |__ src1.h ...
|__ src
   |__ src1.cpp ...
   |__ CMakeLists.txt
|__ Thirdparty                 // 第三方库的源码
   |__ directory1 ...
   |__ CMakeLists.txt
|__ config
   |__ config1.ini ...         // 配置文件
|__ data
   |__ image1.png ...          // 数据文件
CMakeLists.txt

### 目录 project_name/CMakeLists 文件内容 ###
1. cmake_minimum_required( VERSION 2.8 )    // cmake版本
2. project( project_name )                  // 工程名
3. set( CMAKE_BUILD_TYPE Release/Debug )    // 选择“Release“模式或”Debug“模式
4. set( CMAKE_CXX_COMPILER "clang++" )      // 选择编译器（clang++优于gcc++）
5. set( CMAKE_CXX_FLAGS "${CMAKE_CXX_FLAGS} -std=c++11 -march=native -O3 -pthread" )  // 设置编译选项
6. list( APPEND CMAKE_MODULE_PATH ${PROJECT_SOURCE_DIR}/cmake_modules )      // 设置cmake_module路径
7. find_package( 库名 REQUIRED )          // 找库，一般比较出名的库，名称都已经在cmake中定义好了，像opencv、pcl等，如果是没有定义的库，find_package则会去找“Find<LibraryName>.cmake“文件或“<LibraryName>Config.cmake”文件
8. link_directories(路径\库名)               // 加库
9. include_directories(${路径\头文件})       // 加头文件
10. set( EXECUTABLE_OUTPUT_PATH ${PROJECT_SOURCE_DIR}/bin )   // 设置可执行目录
11. add_subdirectory( ${PROJECT_SOURCE_DIR}/src/ )            // 添加子CMakeLists.txt
12. add_subdirectory( ${PROJECT_SOURCE_DIR}/example/ )
### 目录 project_name/src/CMakeLists 文件内容 ###        // 生成编译库
add_library( 库名 src1.cpp src2.cpp src3.cpp )          // 将源文件编译成库
target_link_libraries( 源库名 链接的库 )
### 目录 project_name/example/CMakeLists 文件内容 ###    // 生成可执行文件库
set( build_libs 库名1 库名2 库名3 ...)                   // 将所有库打包
add_executable( 可执行文件 main.cpp )
target_link_libraries( 可执行文件 链接的库 )
 ## git命令使用 ##
 本地建仓
 ```
git init  
 ```
将所有工作区加入到缓冲区
 ```
git add .  
 ```
将缓冲区加入到本地仓
 ```
git commit -m '说明' 
 ```
上传到github
 ```
git push origin master 
 ```
查看状态
 ```
git status
 ```
查看差别
 ```
git diff
 ```
设置username和邮箱
 ```
git config --global user.name "onlyou2030"
git config --global user.email 529647632@qq.com
 ```